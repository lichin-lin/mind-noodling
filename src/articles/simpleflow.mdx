import coverImage from "../assets/simpleflow/cover.png";
import statImage from "../assets/simpleflow/stat.png";
import clipboardInsImage from "../assets/simpleflow/inspector.png";
import diagramImage from "../assets/simpleflow/diagram.png";
import RoutingOrthogonalDiagramImage from "../assets/simpleflow/Routing Orthogonal Diagram.png";
import sf2019 from "../assets/simpleflow/sf-2019.mp4";
import sf2023 from "../assets/simpleflow/sf-2023.mp4";

export const metadata = {
  title: "How Simpleflow was built?",
  slug: "simpleflow",
  description: "A behind-the-scenes look at building Figma plugin Simpleflow",
  publishDate: "2025-11-01",
  tags: [],
};

# How Simpleflow was built?

A behind-the-scenes look at building Figma plugin Simpleflow

<img src={coverImage} alt="Simpleflow cover" />

---

Most of us draw diagrams just to make sense of how things work. Boxes and arrows are the visual glue that help us see connections between ideas.

<figure>
  <img src={diagramImage} alt="Diagram from Rasmus Andersson" />
  <figcaption>A diagram draw by Rasmus Andersson</figcaption>
</figure>

Back then, I’d watch designers bounce between tools, sketching out flows and connectors, only to rebuild everything again inside Figma. Or worse, take a screenshot and drop it in as an image. It never felt right. The connectors looked off, and any time something changed, you had to modify context again.

Then in **2019**, [Figma opened its plugin API](https://www.figma.com/community/plugins). That suddenly made it possible for anyone to fix their own small frustrations. I thought: _what if drawing connectors inside Figma could be as easy as drawing shapes?_ What started as a small weekend experiment slowly turned into a long-term puzzle I couldn’t stop thinking about. That idea grew into [**SimpleFlow**](https://www.figma.com/community/plugin/751821593330638172/simpleflow-figjam-connectors-everywhere).

---

## 2019–2022 · Figuring Out Connectors

The first versions of SimpleFlow were built around one simple goal: **draw connectors that look tidy and don’t cut through everything.**

It sounded straightforward, but routing lines between moving boxes turned out to be a deep problem. What counts as a "good" route? How do you avoid tangled paths or weird overlaps? And what happens when frames start nesting or auto-layout gets involved?

<Video src={sf2019} />

I spent months writing rule-based routing: check positions, test collisions, bend lines at ninety degrees, repeat. If I'd seen [this deep dive article about Routing Orthogonal Diagram Connectors](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70) earlier, it would've saved a lot of time!

<figure>
  <img src={RoutingOrthogonalDiagramImage} alt="Simpleflow stat 22-23" />
  <figcaption>A deep dive that covers most of those edge cases neatly (2020)</figcaption>
</figure>

Then in **April 2021**, [FigJam launched](https://www.figma.com/figjam/). Seeing its live connectors in action was a delightful moment: they updated in real time and solved exactly the kind of problem I’d been wrestling with. It was a reference for what a “good” solution could look like.

At that point, Figma’s API only supported connectors inside FigJam, but not in Figma Design. There was a `createConnector()` method, but it [didn’t work outside that environment](https://developers.figma.com/docs/plugins/api/properties/figma-createconnector/). I tried a few experiments, but none felt natural or reliable. So I decided to step back and pause the project, hoping one day the API might open up to design files too.

---

## 2023 · One Button, Big Turning Point

In **January 2023**, [Danny Postmaa tweets about Figcomponents.com](https://x.com/dannypostmaa/status/1612345747495874561) — a [site](https://www.figcomponents.com/) that let you copy UI components from the web and paste them straight into Figma. That immediately clicked for me: if the browser could paste components, then the same pathway might also paste FigJam connectors.

With that in mind, I simplified SimpleFlow into a single idea: **Copy Connector → Paste → Done.** No extra settings or UI controls, just one simple action that worked.

<Video src={sf2023} />

Long story short, after launch the plugin’s usage grew **almost 8x in six months**. You might be wondering: _how did you make it?_ To make it work I had to dig into how the browser writes data to the clipboard and how Figma reads it back on paste.

<img src={statImage} alt="Simpleflow stat 22-23" />

---

## Opening the Clipboard

At first, I thought it'd be simple — just write the connector data to the clipboard, right? I already had a static file saved in the plugin, but the tricky part was figuring out **what format it needed to be in**.

So I tried pasting the connector into VS Code and Apple Notes to see what would happen. Nothing showed up. That's when I knew something was off. I grabbed [Evercoder's Clipboard Inspector](https://github.com/evercoder/clipboard-inspector) and finally got to peek under the hood at what Figma was actually putting on the clipboard. And that's when it all made sense: Figma wasn't using plain text at all — it was writing **rich `text/html`** with two special attributes tucked inside: `data-metadata` and `data-buffer`.

<img src={clipboardInsImage} alt="Inspector" />

```html
<meta charset="utf-8" />
<div>
  <span data-metadata="<!--(figmeta)eyJm[...]9Cg==(/figmeta)-->"></span>
  <span data-buffer="<!--(figma)ZmlnLW[...]ff/AA==(/figma)-->"></span>
</div>
<span style="white-space:pre-wrap;">Text</span>
```

`data-metadata` starts with **eyJ**, which gives away that it’s Base64-encoded JSON; decoding with `JSON.parse(atob(...))` yields something like:

```JSON
{
  "fileKey": "4XvKUK38NtRPZASgUJiZ87",
  "pasteID": 1261442360,
  "dataType": "scene"
}
```

And the real payload lives inside `data-buffer`. Base64-decoding that produces a binary blob starting with `fig-kiwi`. I learned about this from [Alex Harri’s excellent deep dive](https://alexharri.com/blog/clipboard) on the Clipboard API, which explains not just how clipboard formats work in browsers, but also how Figma encodes its own data.

That fig-kiwi string turned out to be Figma’s internal [Kiwi format](https://github.com/evanw/kiwi) (created by co-founder & former CTO Evan Wallace) the same schema used to encode Figma files. So what I needed to store wasn’t just vector data; it was a tiny `.fig` file encoded into the clipboard.

---

## Decode fig-kiwi

So how does copying in Figma actually work? In short, Figma creates a small `.fig` file behind the scenes, encodes it in Base64, places that string inside the `data-buffer` attribute of an empty HTML `<span>` element, and then writes the entire HTML snippet to the clipboard as `text/html`.

You can also test this yourself: decode the Base64 string from `data-buffer`, save it as `sample.fig`, and upload it to [Evan Wallace’s .fig parser](https://madebyevan.com/figma/fig-file-parser/). You’ll see a miniature Figma file, complete with nodes and styles, representing exactly what you copied.

At first, this approach might seem overcomplicated, but there’s a good reason for it. As [Alex Harri explains in his article on clipboard formats](https://alexharri.com/blog/clipboard), browsers have to translate data between web and operating system clipboard APIs, and each OS supports only a few “standard” formats — like plain text, HTML, and PNG. Custom types (like Figma’s internal format) don’t map cleanly across apps.

By storing data as `text/html`, Figma ensures that the clipboard contents are recognized by all operating systems. That’s why you can copy something from Figma’s web app and paste it seamlessly into the desktop app — the browser and OS both understand what’s being transferred.

---

## Back to the plugin

Follow the same process, the plugin can now generate connectors dynamically: adjusting color, stroke width, or corner rounding. I could even **create connector types that aren’t available in Figma’s official UI**. Because the plugin builds connectors directly at the data level, it offers far more precise control without the usual editor limitations.

Getting clipboard writes to behave inside Figma’s plugin sandbox was still tricky. Some clipboard APIs are deprecated, and browser behavior can be inconsistent. This [community thread](https://forum.figma.com/ask-the-community-7/write-to-clipboard-from-custom-plugin-23974) became my main reference. After plenty of trial and error, I found a setup stable enough to rely on.

That’s how SimpleFlow’s **Copy Connector** button actually works, it assembles a valid connector file, encodes it the same way Figma does, and lets Figma handle the paste natively.

---

## 2025 · When Figma Closed the API Door

Around mid-2025, Figma tightened its API, and a lot of plugins suddenly stopped working. Developers began seeing errors like this:

```plaintext title="error.log"
Error: in clone: Cloning CONNECTOR nodes is not supported in the current editor
```

> “The CONNECTOR node type is specific to FigJam and should never have been allowed by the API in Figma Design… The API has now been updated to enforce this consistently.”  
> — **ksn, Figma Community Support**

A discussion on the [Figma Forum](https://forum.figma.com/ask-the-community-7/has-figma-changed-or-restricted-its-clone-function-api-43505) explained that no more `createConnector()` calls and no more `clone()` workarounds, FigJam connectors were officially off-limits inside Figma Design. Many popular plugins broke overnight. SimpleFlow, however, kept working.

Both approaches were technically programmatic: one used Figma’s API to create connectors directly on the canvas, while mine **generated the same connector data into the clipboard** instead. Users still had to press hotkey **Cmd/Ctrl + V** to paste it, but since Figma treats paste as a valid action, it remained supported. That small difference was enough to keep the plugin alive.

---

## Looking Back

What began as a weekend experiment to route lines around boxes turned into an unexpected API journey. When geometry got tricky and the Figma API reached its limits, curiosity led me to explore how copy-paste actually works — and that turned out to be the better path.

Along the way, I learned a few things:

Every copy in Figma is essentially a tiny .fig file.

Understanding clipboard formats can sometimes be more powerful than private APIs.

Simplicity scales — one well-designed button can go a long way.

Today, SimpleFlow quietly helps creators turn their ideas into clear diagrams inside Figma. I’m glad that a small weekend project taught me so much — lessons that have carried into every other plugin I’ve built since.
---

## References

- [SimpleFlow Plugin](https://www.figma.com/community/plugin/751821593330638172/simpleflow-figjam-connectors-everywhere)
- [Routing Orthogonal Connectors in JavaScript](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70)
- [Figma createConnector() API Docs](https://developers.figma.com/docs/plugins/api/properties/figma-createconnector/)
- [Figcomponents](https://www.figcomponents.com/)
- [Danny Postmaa’s Tweet](https://x.com/dannypostmaa/status/1612345747495874561)
- [Evan Wallace’s .fig Parser](https://madebyevan.com/figma/fig-file-parser/)
- [Evercoder’s Clipboard Inspector](https://github.com/evercoder/clipboard-inspector)
- [The web’s clipboard, and how it stores data of different types](https://alexharri.com/blog/clipboard)
- [Community Thread: Write to Clipboard from Plugin](https://forum.figma.com/ask-the-community-7/write-to-clipboard-from-custom-plugin-23974)
- [Forum Thread: Connector Clone Restriction](https://forum.figma.com/ask-the-community-7/has-figma-changed-or-restricted-its-clone-function-api-43505)
