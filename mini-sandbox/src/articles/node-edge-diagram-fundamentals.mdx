import Example1 from '../examples/Example1'
import Example2 from '../examples/Example2'
import Example3 from '../examples/Example3'
import Example4 from '../examples/Example4'
import Example5 from '../examples/Example5'
import Example6 from '../examples/Example6'
import Example7 from '../examples/Example7'
import Example8 from '../examples/Example8'
import Example9 from '../examples/Example9'
import Example10 from '../examples/Example10'
import Example11 from '../examples/Example11'
import Example12 from '../examples/Example12'

# Building Interactive Workflow Diagrams

A diagram begins with a simple question: **how do I make complexity visible?**

Not just visible—manipulable, explorable, alive. The kind that updates when your system changes, that reveals structure you couldn't see in text or tables.

I've been working on this fun exploration for a while and would like to bring you on this fun journey as well. We'll start from the most fundamental primitive and work our way up to layout algorithms that organize nodes automatically.

---

### 1. The Empty Canvas

It all starts with space. An infinite, blank surface waiting for structure.

To map a system, we first need to identify its landmarks. We could call these **nodes**. Before we worry about connections or flows, we must simply give these pieces a place to exist.

<Example1 />

---

### 2. Drawing Connections

Once the nodes are in place, we draw lines. These lines are the relationship made visible. They turn a collection of isolated parts into a cohesive system.

<Example2 />

Suddenly, we can see how data flows. **The edge is where the story lives.** Without it, nodes are just dots. With it, they become a narrative of cause and effect.

---

### 3. When Manual Breaks Down

But what happens when the system grows? With more and more nodes on the canvas, relationships become tangled. We start to get lost in our own diagram.

<Example3 />

**This is the breaking point.** What felt intentional with a few blocks now feels like chaos. Manual positioning doesn't scale. The diagram has outgrown our ability to manage it by hand.

---

### 4. Algorithms as Collaborators

This is where we stop arranging nodes ourselves and start exploring layout algorithms. Instead of fighting chaos, we need a systematic way to organize these elements.

One of the most popular approaches is the **Sugiyama framework** (Layered Graph Drawing). Introduced by Kozo Sugiyama in [1981](https://ieeexplore.ieee.org/document/4308636), it revolutionized how we visualize hierarchical structures. The idea is elegant: arrange nodes in layers so that edges flow in a single direction (usually top-to-bottom) with minimal crossing.

<Example4 />
```javascript

import {(graphStratify, sugiyama, layeringSimplex)} from 'd3-dag'

// Build a directed acyclic graph from your data
const builder = graphStratify()
.id((d) => d.id)
.parentIds((d) => d.parentIds)

const dag = builder(nodes)

// Apply Sugiyama layout algorithm
const layout = sugiyama()
.layering(layeringSimplex()) // Assign nodes to layers
.decross(decrossTwoLayer()) // Minimize edge crossings
.nodeSize([150, 60]) // Set node dimensions

const { width, height } = layout(dag) // Get calculated dimensions

// Now each node has x, y coordinates automatically assigned

````

With the algorithm in charge, the diagram suddenly makes sense. We've moved from manual placement to **structural clarity**.

---

### 5. Smooth Paths

Now that we have structure, we can refine how connections flow between nodes. Straight lines work, but curved paths guide the eye more naturally. They soften the visual noise and make complex hierarchies easier to trace.

<Example5 />

```javascript
const generateRoundedVerticalPath = (from, to) => {
  const deltaX = to.x - from.x
  const absDeltaX = Math.abs(deltaX)

  // Use straight line if nodes are vertically aligned
  if (absDeltaX < 10) {
    return `M ${from.x},${from.y} L ${to.x},${to.y}`
  }

  const cornerRadius = 12
  const verticalSplit = (from.y + to.y) / 2
  const directionX = deltaX > 0 ? 1 : -1

  // Create path with rounded 90-degree turns
  return `
    M ${from.x},${from.y}
    L ${from.x},${verticalSplit - cornerRadius}
    A ${cornerRadius},${cornerRadius} 0 0 ${directionX > 0 ? 0 : 1}
      ${from.x + directionX * cornerRadius},${verticalSplit}
    L ${to.x - directionX * cornerRadius},${verticalSplit}
    A ${cornerRadius},${cornerRadius} 0 0 ${directionX > 0 ? 1 : 0}
      ${to.x},${verticalSplit + cornerRadius}
    L ${to.x},${to.y}
  `
}
````

---

### 6. Bringing Edges to Life

Static lines show structure, but they don't convey **state**. Is data flowing? Is a process running? Are dependencies being resolved in real-time?

Here's a question: **How do you show movement without showing objects moving?**

By using `stroke-dasharray` and `stroke-dashoffset`, we create a "drawing" effect—the edge appears to fill from start to finish, like watching data propagate through the connection. It's less about individual packets and more about the **act of connection** itself.

<Example6 />

```css
@keyframes dash {
  0% {
    stroke-dashoffset: 100%;
  }
  100% {
    stroke-dashoffset: 0%;
  }
}

.fill-edge {
  stroke-dasharray: 100%;
  stroke-dashoffset: 100%;
  animation: dash 2s ease-in-out forwards;
}
```

```jsx
<path
  d={path}
  className="fill-edge"
  stroke="#BBB"
  strokeWidth={1.5}
  style={{ animationDelay: `${delay}s` }}
/>
```

Why does this matter? Because **motion encodes meaning.** A static diagram tells you what's connected. An animated one tells you what's happening right now.

---

### 7. Motion Patterns for Status

Different motion patterns can signal different states. The previous example animated the stroke itself. But sometimes you want something more literal—actual objects moving along the edge.

Using SVG's `<animateMotion>`, we can make circles travel along the exact path of the edge. This works for showing individual packets, messages, or tasks moving through the system.

<Example7 />

```jsx
<svg>
  <defs>
    {/* Define the path once */}
    <path id="edge-path-1" d={curvedPath} />
  </defs>

  {/* Static edge */}
  <path d={curvedPath} stroke="#333" strokeWidth={1.5} />

  {/* Animated circle following the path */}
  <circle r={3} fill="#BBB">
    <animateMotion dur="5s" begin="0.2s" repeatCount="indefinite">
      <mpath href="#edge-path-1" />
    </animateMotion>
  </circle>
</svg>
```

---

### 8. Rich Status Patterns

Real systems involve states between every two nodes. A connection might be idle, actively processing, completed, or even failed. Each state carries meaning, and the challenge is making that meaning instantly visible without adding clutter.

Can motion replace text labels?

<Example8 />

A slow pulse says "waiting, not urgent." A fast pulse says "actively processing." A fill animation says "completed."

```jsx
const AnimatedEdge = ({ path, status }) => {
  const [localState, setLocalState] = useState(status)

  // IDLE: Slow, subtle pulse
  // PROCESSING: Fast, bright pulse with gradient
  // COMPLETED: Fill animation with success color

  return (
    <AnimatePresence mode="wait">
      {localState === 'IDLE' && (
        <circle r={25} fill="url(#idle-gradient)">
          <animateMotion dur="6s" repeatCount="indefinite">
            <mpath href="#path" />
          </animateMotion>
        </circle>
      )}

      {localState === 'PROCESSING' && (
        <circle r={30} fill="url(#processing-gradient)">
          <animateMotion dur="2s" repeatCount="indefinite">
            <mpath href="#path" />
          </animateMotion>
        </circle>
      )}

      {localState === 'COMPLETED' && (
        <path d={path} className="edge-completed" />
      )}
    </AnimatePresence>
  )
}
```

---

### 9. Scaling with Zoom and Pan

As diagrams grow, a fixed viewport becomes limiting. You need to see the whole picture, but also zoom into specific details. Thirty nodes? A hundred? The same principles apply, but now you need navigation.

<Example9 />

This is where diagrams become **zoom/pan-able**. You're not just looking at a static map anymore. You're navigating through your system, choosing what to focus on, discovering patterns at different scales.

```javascript
import { select, zoom } from 'd3'

const zoomBehavior = zoom()
  .scaleExtent([0.2, 5]) // Min/max zoom levels
  .on('zoom', (event) => {
    // Apply transform to your SVG groups
    select('#edges-group').attr('transform', event.transform)
    select('#nodes-overlay').style(
      'transform',
      `translate(${event.transform.x}px, ${event.transform.y}px) 
       scale(${event.transform.k})`
    )
  })

// Attach to container
select(containerRef).call(zoomBehavior)
```

---

### 10. When Edges Overlap

As relationships grow more complex, edges start crossing each other. Multiple connections converge on the same nodes. What was clear with a few edges becomes a tangled mess with many.

The diagram below lets you click on nodes to highlight their connections. It doesn't eliminate the overlap, it just makes it possible to selectively focus.

<Example10 />

This reveals a fundamental tension: **some structures are inherently dense**, and no amount of clever layout will make every edge perfectly clear at once. Sometimes the best approach isn't to eliminate the problem, but to give users simple interactions to navigate it themselves.

---

### 11. Way toward smart Routing

We've been using Sugiyama layout, which works well for most hierarchical diagrams. For simple cases, it's more than enough.

But there's a group of researchers who've spent years digging deeper into this problem. The [KIELER team](https://github.com/kieler) at Kiel University, working within the Eclipse Foundation, built **ELK.js** (Eclipse Layout Kernel)—a library that treats graph layout not as a solved problem, but as an active research area.

<Example11 />

The difference? **Smart edge routing.** ELK's edges navigate around nodes instead of cutting straight through. The algorithm treats routing as a pathfinding problem—edges actively avoid obstacles, maintaining clearance you can control with options like `spacing.edgeNode`.

```javascript
import ELK from 'elkjs/lib/elk.bundled'

const elk = new ELK()

const elkGraph = {
  id: 'root',
  layoutOptions: {
    'elk.algorithm': 'layered',
    'elk.direction': 'DOWN',
    'elk.spacing.nodeNode': '40',
    'elk.spacing.edgeNode': '80', // Control edge-to-node spacing
  },
  children: nodes.map((n) => ({
    id: n.id,
    width: 140,
    height: 48,
  })),
  edges: edges.map((e) => ({
    id: e.id,
    sources: [e.source],
    targets: [e.target],
  })),
}

const layout = await elk.layout(elkGraph)
```

This is particularly valuable for dense graphs where d3-dag's straight connections would slice through unrelated nodes. ELK doesn't just minimize crossings; it respects the space nodes occupy. Even though the smart routing can sometimes feel over-engineered for simple graphs. But when you need it, nothing else comes close.

---

### 12. A Lightweight Layout Engine

ELK is impressive, but it comes with trade-offs. The bundled worker weighs in at **~1.5 MB minified**, larger than many entire web apps. It ships dozens of algorithms and hundreds of configuration options, some of which you'll never touch.

For embedded diagrams or projects where bundle size matters, that's a lot of overhead for "put nodes in layers." So what if we built just enough? A layout engine that does one thing well: organize nodes into layers with clean, routed edges.

<Example12 />

This custom layout lives in a ~1,400 lines of TypeScript, simple enough to debug without diving into library internals. In the bundle it compiles to just a ~30kB, roughly **50× smaller** than ELK.js.

The trade-off is real: you lose ELK's sophisticated obstacle avoidance and its library of alternative algorithms. But for small-to-medium DAGs where you control the structure, a focused implementation gives you something more valuable: **code you actually own**. You can tweak the layout engine or add features without waiting on upstream changes or fighting an unfamiliar codebase.
