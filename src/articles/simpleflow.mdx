import coverImage from "../assets/simpleflow/cover.png";
import statImage from "../assets/simpleflow/stat.png";
import clipboardInsImage from "../assets/simpleflow/inspector.png";
import diagramImage from "../assets/simpleflow/diagram.png";
import RoutingOrthogonalDiagramImage from "../assets/simpleflow/Routing Orthogonal Diagram.png";
import sf2019 from "../assets/simpleflow/sf-2019.mp4";
import sf2023 from "../assets/simpleflow/sf-2023.mp4";
import sf2025 from "../assets/simpleflow/sf-2025.mp4";
import figFileInspector from "../assets/simpleflow/fig-file-inspector.mp4";

export const metadata = {
  title: "How Simpleflow Was Built",
  slug: "simpleflow",
  description:
    "From geometry algorithms to clipboard hacking: the story behind a Figma plugin",
  publishDate: "2025-11-01",
  tags: [],
};

<p className="time" dateTime="2025-11-01">
  November 1, 2025
</p>

<div className="article-page-header">
# How Simpleflow Was Built

From geometry algorithms to clipboard hacking: the story behind a Figma plugin

</div>

<img src={coverImage} alt="Simpleflow cover" />

---

Most of us draw diagrams just to make sense of how things work. Boxes and arrows are the visual glue that help us see connections between ideas.

<figure>
  <img src={diagramImage} alt="Diagram from Rasmus Andersson" />
  <figcaption>A diagram draw by Rasmus Andersson</figcaption>
</figure>

Back then, I‚Äôd watch designers bounce between tools, sketching out flows and connectors, only to rebuild everything again inside Figma. The connectors looked off, and any time something changed, you had to modify context again.

Then in **2019**, [Figma opened its plugin API](https://www.figma.com/community/plugins). That suddenly made it possible for anyone to fix their own small frustrations. I thought: _what if drawing connectors inside Figma could be as easy as drawing shapes?_ What started as a small weekend experiment slowly turned into a long-term puzzle I couldn‚Äôt stop thinking about. That idea grew into [**SimpleFlow**](https://www.figma.com/community/plugin/751821593330638172/simpleflow-figjam-connectors-everywhere).

---

### Figuring Out Connectors

The first versions of SimpleFlow were built around one simple goal: **draw connectors that look tidy and don‚Äôt cut through everything.**

It sounded straightforward, but routing lines between moving boxes turned out to be a deep problem. What counts as a "good" route? How do you avoid tangled paths or weird overlaps? And what happens when frames start nesting or auto-layout gets involved?

<Video src={sf2019} />

I spent months back in 2020 writing rule-based routing: check positions, test collisions, bend lines at ninety degrees, repeat. If I'd seen [this deep dive article about Routing Orthogonal Diagram Connectors](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70) earlier, it would've saved a lot of time!

<figure>
  <img src={RoutingOrthogonalDiagramImage} alt="Simpleflow stat 22-23" />
  <figcaption>
    A deep dive that covers most of those edge cases neatly (2020)
  </figcaption>
</figure>

Then in **April 2021**, [FigJam launched](https://www.figma.com/figjam/). Seeing its live connectors in action was a delightful moment: they updated in real time and solved exactly the kind of problem I‚Äôd been wrestling with. It was a reference for what a ‚Äúgood‚Äù solution could look like.

At that point, Figma‚Äôs API only supported connectors inside FigJam, but not in Figma Design. There was a `createConnector()` method, but it [didn‚Äôt work outside that environment](https://developers.figma.com/docs/plugins/api/properties/figma-createconnector/). I tried a few experiments, but none felt natural or reliable. So I decided to step back and pause the project, hoping one day the API might open up to design files too.

---

### One Button, Big Turning Point

In **January 2023**, [Danny Postmaa tweets about Figcomponents.com](https://x.com/dannypostmaa/status/1612345747495874561) ‚Äî a [site](https://www.figcomponents.com/) that let you copy UI components from the web and paste them straight into Figma. That immediately clicked for me: if the browser could paste components, then the same pathway might also paste FigJam connectors.

With that in mind, I simplified SimpleFlow into a single idea: **Copy Connector ‚Üí Paste ‚Üí Done.** No extra settings or UI controls, just one simple action that worked.

<Video src={sf2023} muted />

Long story short, after launch the plugin‚Äôs usage grew **almost 8x in six months (Dec, 2022 ‚Üí Jun, 2023)**. You might be wondering: _how did you make it?_ To make it work I had to dig into how the browser writes data to the clipboard and how Figma reads it back on paste.

<img src={statImage} alt="Simpleflow stat 22-23" />

---

### Opening the Clipboard

At first, I thought it'd be simple: just write the connector data to the clipboard, right? I already had a static file saved in the plugin, but the tricky part was figuring out **what format it needed to be in**.

So I tried pasting the connector into VS Code and Apple Notes to see what would happen. Nothing showed up. That's when I knew something was off. I found this handy website [Evercoder's Clipboard Inspector](https://github.com/evercoder/clipboard-inspector) and finally got to peek under the hood at what Figma was actually putting on the clipboard. And that's when it all made sense: Figma wasn't using plain text at all, it was writing **rich `text/html`** with two special attributes tucked inside: `data-metadata` and `data-buffer`.

<img src={clipboardInsImage} alt="Inspector" />

```html lines={[3,4]} showLineNumbers
<meta charset="utf-8" />
<div>
  <span data-metadata="<!--(figmeta)eyJm[...]9Cg==(/figmeta)-->"></span>
  <span data-buffer="<!--(figma)ZmlnLW[...]ff/AA==(/figma)-->"></span>
</div>
<span style="white-space:pre-wrap;">Text</span>
```

`data-metadata` starts with **eyJ**, which gives me a sense of Base64-encoded JSON; decoding with `JSON.parse(atob(...))` yields something like:

```JSON
{
  "fileKey": "4XvKUK38NtRPZASgUJiZ87",
  "pasteID": 1261442360,
  "dataType": "scene"
}
```

And the real payload lives inside `data-buffer`. Base64-decoding that produces a binary blob starting with `fig-kiwi`. I learned about this from [Alex Harri‚Äôs excellent deep dive](https://alexharri.com/blog/clipboard) on the Clipboard API, which explains not just how clipboard formats work in browsers, but also how Figma encodes its own data:

```JSON
fig-kiwiF\x00\x00\x00\x1CK\x00\x00¬µ¬Ω\v\x9CdI[...]\x197√ú\x83\x03
```

This fig-kiwi string turned out to be Figma‚Äôs internal [Kiwi format](https://github.com/evanw/kiwi) (created by co-founder & former CTO Evan Wallace). So what I needed to store inside the static file wasn‚Äôt just vector data; it was a tiny `.fig` file!

---

### Inside fig-kiwi

How does copying in Figma actually work? In short, Figma turns the selected elements (area) into a small `.fig` file through fig-kiwi, encodes it in Base64, places that string inside the `data-buffer` attribute of an empty HTML `<span>` element, and then writes the entire HTML snippet to the clipboard as `text/html`.

You can also test this yourself: try to create a new figma file, save and upload it to [Evan Wallace‚Äôs .fig parser](https://madebyevan.com/figma/fig-file-parser/). You‚Äôll see the actual contents, including Design data (.fig), Meta data (.json), and the thumbnail.

<Video src={figFileInspector} />



At first, this approach might seem overcomplicated, but there‚Äôs a good reason for it. As [Alex Harri explains in his article on clipboard formats](https://alexharri.com/blog/clipboard), browsers have to translate data between web and operating system clipboard APIs, and each OS supports only a few ‚Äústandard‚Äù formats, like plain text, HTML, and PNG. Custom types (like Figma‚Äôs internal format) don‚Äôt map cleanly across apps.

By storing encoded data as `text/html`, Figma ensures that the clipboard contents are recognized by all operating systems. That‚Äôs why you can copy something from Figma‚Äôs web app and paste it seamlessly into the desktop app, the browser and OS both understand what‚Äôs being transferred.

---

### Back to the plugin

Once I understood how fig-kiwi and clipboard encoding worked, I could finally rebuild SimpleFlow from the inside out. The plugin can now generate connectors dynamically: adjusting color, stroke width, or corner rounding.

It can even **create connector types that aren‚Äôt available in Figma‚Äôs official UI**. Because the plugin builds connectors directly at the data level, it offers far more precise control without the usual editor limitations:

```JSON lines={[19,23]} showLineNumbers
/**
* Working at the schema level unlocks two key advantages:
*
* 1. Access to undocumented properties: Some connector properties like `connectorTextMidpoint` 
*    exist in the schema but aren't exposed through Figma's official API documentation.
*    https://developers.figma.com/docs/plugins/api/api-reference/
*
* 2. Bypass UI limitations: You can apply config that Figma's UI doesn't normally allow,
*    such as setting `connectorLineStyle` from "ELBOWED"` to `CURVED` type.
*/

{
  ...,
  type: "CONNECTOR",
  visible: true,
  opacity: 1,
  strokeWeight: 0,
  strokeAlign: "CENTER",
  connectorLineStyle: "ELBOWED", // üìç customize to `CURVED` type is possible!
  connectorStartCap: "NONE",
  connectorEndCap: "ARROW_LINES",
   // üìç or access to internal props
  connectorTextMidpoint: { section: "MIDDLE_TO_END", offset: 0.04886624589562416, offAxisOffset: "NONE" },
  connectorStart: {
    magnet: "NONE"
    ...,
  },
  connectorEnd: {
    magnet: "NONE"
    ...,
  },
  ...
}
```

<Video src={sf2025} />

On the other hand, getting **clipboard writes to behave** inside Figma‚Äôs plugin sandbox was tricky. Some clipboard APIs are deprecated, and browser behavior can be inconsistent. This [community thread](https://forum.figma.com/ask-the-community-7/write-to-clipboard-from-custom-plugin-23974) became my main reference. After plenty of trial and error, I found a setup stable enough to rely on.

```js
  const setToClipboard = async (data) => {
    try {
      /**
       * As with many new APIs, the Clipboard API is only supported for pages served over HTTPS.
       * To help prevent abuse, clipboard access is only allowed when a page is the active tab.
       * Pages in active tabs can write to the clipboard without requesting permission,
       * but reading from the clipboard always requires permission.
       */
      const contentBlob = new Blob([data], { type: 'text/html' });
      const item = new clipboard.ClipboardItem({ 'text/html': contentBlob });

      clipboard.write([item]).then(
        () => {
          console.log('Copied to clipboard successfully!');
        },
        (error) => {
          console.error('unable to write to clipboard. Error:');
        }
      );
    } catch (err) {
      new Error(err);
    }
  };
```

That‚Äôs how SimpleFlow‚Äôs **Copy Connector** button actually works, it assembles a valid element schema, encodes it the same way Figma does, save the data into Clipboard, and relies on Figma's native parsing process when pasting.

---

### When Figma Closed the API Door

Around mid-2025, Figma tightened its API. Developers began seeing errors like this:

```plaintext
Error: in clone: Cloning CONNECTOR nodes is not supported in the current editor
```

> ‚ÄúThe CONNECTOR node type is specific to FigJam and should never have been allowed by the API in Figma Design‚Ä¶ The API has now been updated to enforce this consistently.‚Äù  
> ‚Äî **ksn, Figma Community Support**

A discussion on the [Figma Forum](https://forum.figma.com/ask-the-community-7/has-figma-changed-or-restricted-its-clone-function-api-43505) explains that no more `createConnector()` calls and `clone()` workarounds, FigJam connectors were officially off-limits inside Figma Design. Many popular plugins broke overnight. SimpleFlow, however, kept working.

Both approaches were technically programmatic: one used Figma‚Äôs API to create connectors directly, while mine **generated the connector through actual element schema** instead. Users still had to press hotkey **Cmd/Ctrl + V** to paste it from Clipboard, but since Figma treats paste as a valid action, it remained supported. That small difference was enough to keep the plugin alive.

---

### Looking Back

What began as a weekend experiment to route lines around boxes turned into an unexpected API journey. When geometry got tricky and the Figma API reached its limits, curiosity led me to explore how copy-paste actually works, and turned out to be the better path. Along the way, I learned a few things:

1. Every copy in Figma is essentially a tiny `.fig` file.
2. Understanding clipboard formats can sometimes be more powerful than private APIs.
3. Simplicity scales ‚Äî one button can go a long way.

Today, SimpleFlow helps thousands of creators turn their ideas into clear diagrams inside Figma. I‚Äôm glad that a small project taught me so much ‚Äî lessons that have carried into [every other plugin](https://www.figma.com/@lichin) I‚Äôve built since.

---

### References

- [SimpleFlow Plugin](https://www.figma.com/community/plugin/751821593330638172/simpleflow-figjam-connectors-everywhere)
- [Routing Orthogonal Connectors in JavaScript](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70)
- [Figma createConnector() API Docs](https://developers.figma.com/docs/plugins/api/properties/figma-createconnector/)
- [Figcomponents](https://www.figcomponents.com/)
- [Danny Postmaa‚Äôs Tweet](https://x.com/dannypostmaa/status/1612345747495874561)
- [Evan Wallace‚Äôs .fig Parser](https://madebyevan.com/figma/fig-file-parser/)
- [Evercoder‚Äôs Clipboard Inspector](https://github.com/evercoder/clipboard-inspector)
- [The web‚Äôs clipboard, and how it stores data of different types](https://alexharri.com/blog/clipboard)
- [Community Thread: Write to Clipboard from Plugin](https://forum.figma.com/ask-the-community-7/write-to-clipboard-from-custom-plugin-23974)
- [Forum Thread: Connector Clone Restriction](https://forum.figma.com/ask-the-community-7/has-figma-changed-or-restricted-its-clone-function-api-43505)
